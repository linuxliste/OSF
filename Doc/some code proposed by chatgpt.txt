// this code has been generated by chat gpt when I asked for best algoritm for trapezoidal bldc

/*
Here some explanation

Super — voici un schéma de contrôle complet (texte + explications) intégrant les optimisations « couple plus lisse / bruit réduit » pour un pilotage 6-pas d’un BLDC trapézoïdal, sans passer au FOC. Je fournis aussi des recommandations pratiques (fréquences, filtres, gains initiaux) et un pseudo-code pour l’implémentation.

Schéma global (bloc-diagramme ASCII)
            +--------------------- Speed PI --------------------+
            | (ω_ref, ω_meas) -> e -> PI -> Iq_ref (torque cmd)   |
            +--------------------------------------------------+
                                   |
                                   v
                    +-----------------------------+
                    | Torque→Phase current map    |  <- map Iq_ref -> I_phaseA/B target
                    | (2 phases conduct, 120°)    |
                    +-----------------------------+
                                   |
                                   v
        +----------------+        +-----------------+       +-----------------+
        | Current PI A   |<--Ia-- | Current PI B    |<--Ib--| Current PI C    |<-Ic (optional)
        | (per-phase)    |        | (per-phase)     |       | (only for meas.) |
        +----------------+        +-----------------+       +-----------------+
           | dutyA_cmd                | dutyB_cmd
              \                      /
               \                    /
                v                  v
                 +------------------------------------+
                 |  PWM Generator (synchronous PWM)  |
                 |  - center/edge aligned as chosen  |
                 |  - deadtime comp & synchronous FW |
                 |  - current shaping / tapering    |
                 |  - optional 3rd harmonic inj.    |
                 +------------------------------------+
                                   |
                                   v
                            Power stage (3-phase inverter)
                                   |
                                   v
                                 Motor
                                   ^
                 +------------------------------------+
                 | Feedback: Ia, Ib (shunt/amps)      |
                 | Position: Hall sensors (or ZC)     |
                 | Speed: derived from Hall or encoder|
                 +------------------------------------+

Où s’appliquent les optimisations (raccourci)

Régulation du courant crête : blocs Current PI A/B — régulent I_phase dans les phases actives.

PWM synchrone + freewheel : dans PWM Generator — on commande aussi le low-side pour mieux contrôler freewheeling.

Compensation de deadtime : PWM Generator ajuste duty pour compenser les délais.

Shaping (arrondi des transitions) : applique une rampe/taper sur duty en fin de période de conduction.

Injection harmonique 3 : modifie la référence de duty pour « aplatir » la forme du courant.

Lead angle : avant la commutation, décale la table de commutation en fonction de la vitesse.

Détails pratiques et paramètres recommandés

Fréquences

PWM carrier : 16–32 kHz (plus haut réduit acoustique mais augmente commutation losses). 16 kHz est un bon départ.

Boucle courant (control ISR) : 2–5 kHz (ex. 4 kHz) — idéalement synchronisé à PWM (exécution centre-PWM).

Boucle vitesse : 200–1000 Hz (ex. 200–500 Hz).

Mesures

Prélever courant au milieu du duty (center sampling) pour réduire erreur due au commutation.

Filtre anti-aliasing : passe-bas ~ (fs/5) pour le courant (fs = sampling courant).

Gains initialisés (points de départ)

Current PI: Kp_current = (L / Tr) style heuristique non trivial — si pas d’identification, commencer par Kp = 0.1 × (Vbus / Imax) scaled, Ki such that bandwidth ~ fs/10.

Speed PI: Kp_speed petit, Ki speed pour régler à quelques Hz de bande (ex. Kp_speed = 0.05, Ki_speed = 1.0*sec^-1) — ces valeurs sont très dépendantes du moteur/charge; vérifiez en boucle fermée.

Anti-windup : impératif sur PI courant et PI vitesse (clamp integrator to duty limits).

Limitation : limiter Iq_ref à Imax, et dériver consigne de courant selon température/overcurrent.

Techniques d’implémentation (algos)
1) Régulation du courant crête dans les 2 phases

Mesurer Ia et Ib (ou Ia et Ic, selon phases actives).

Calculer erreur: eA = I_A_ref − I_A_meas → Current PI → dutyA. Même pour phase B.

Pendant la conduction 120°, seules 2 phases ont référence non-nulle ; la phase flottante peut être mesurée pour diagnostic.

2) PWM synchrone + deadtime compensation

Activez MOSFET bas pour freewheeling (synchronous).

Mesurez deadtime effect en calibration : détecter la différence Ia mesuré vs estimé si deadtime nulle. Ajuster duty:

duty_corrected = duty_raw + K_dead * sign(duty_raw - 0.5)


(plus précis: compenser à chaque transition en augmentant/reduisant duty selon signaux de sortie)

Pour centre-aligned PWM : lire courant à la position centrale et exécuter contrôle immédiatement.

3) Shaping (tapering) de la forme de courant

À l’entrée/sortie de chaque pas de 120°, appliquer une rampe exponentielle courte (10–50 µs) sur la consigne de courant pour lisser la transition :

I_ref(t) = I_prev + (I_next - I_prev) * (1 - exp(-t/τ))


τ petit (p. ex. 20–200 µs) selon inductance. Cela réduit les chocs instantanés.

4) Injection d’harmonique 3 (optionnel)

Calculer une composante supplémentaire à ajouter à la commande de phase pendant la conduction :

I_ref_phase = I_base + A3 * sin(3*θ_elec + φ)


avec A3 ≈ 0.03–0.10 * I_base (3–10% typ.), φ réglable.

Le but : compenser la non-linéarité de la f.e.m. et aplatir le couple.

5) Advance (lead) scheduling

Lead_angle = f(ω) ; typ. start à 0° à bas régime, montée linéaire jusqu’à 10–30° à haute vitesse selon inductance et friction.

Avant chaque commutation, on indexe la table de commutation à θ + Lead_angle.

Table de commutation 6-pas (exemple rapide)
Step	High	Mid	Low	Active phases
1	A+	B-	C	A+, B-
2	A+	C-	B	A+, C-
3	B+	C-	A	B+, C-
4	B+	A-	C	B+, A-
5	C+	A-	B	C+, A-
6	C+	B-	A	C+, B-

Appliquez lead_angle avant d’indexer.

Pseudo-code (interrupt / ISR centré PWM)
// Executed at center of PWM (fs_current)
void pwm_center_isr() {
  // READS
  Ia = read_current_A();
  Ib = read_current_B();
  theta = read_hall_or_angle();         // electrical angle (discrete 6 states + interpolation)
  omega = compute_speed(theta);

  // SPEED LOOP (slower: execute every N current loops) -> sets Iq_ref
  if (speed_loop_timer_elapsed) {
    speed_error = speed_ref - omega;
    Iq_ref = speed_PI(speed_error);
    clamp(Iq_ref, -I_max, I_max);
  }

  // MAP torque -> per-phase current refs (2 phases active)
  get_active_phases(theta, &phaseA, &phaseB);
  IrefA = map_torque_to_phase_current(Iq_ref, phaseA);
  IrefB = map_torque_to_phase_current(Iq_ref, phaseB);

  // SHAPING: apply short ramp if commutation just happened
  IrefA = apply_tapering(IrefA);
  IrefB = apply_tapering(IrefB);

  // CURRENT PI
  dutyA = current_PI_A(IrefA - Ia);
  dutyB = current_PI_B(IrefB - Ib);

  // 3rd harmonic injection (if enabled)
  dutyA += third_harmonic_component(theta);
  dutyB += third_harmonic_component(theta);

  // DEADTIME COMPENSATION
  dutyA = deadtime_compensate(dutyA);
  dutyB = deadtime_compensate(dutyB);

  // APPLY lead angle for commutation index (done in commutation handler)
  schedule_commutation(theta + lead_angle(omega));

  // UPDATE PWM registers (synchronous)
  set_pwm(dutyA, dutyB, dutyC_for_freewheel());
}

Mesures de sécurité & diagnostics

Vérification de sur-courant, overvoltage, watchdog.

Mesurer courant sur les deux phases; si une seule sonde disponible, reconstruire via Ia + Ib + Ic = 0 (nécessite haute précision).

Mode open-loop d’une rampe douce si sensorless au démarrage (IPD).

Résumé / checklist pour l’implémentation

Implémentez la boucle courant (ISR centre-PWM) et la mesure de courant fiable.

Ajoutez PWM synchrone et compensation de deadtime.

Mettez en place shaping/taper (rampe courte à chaque commutation).

Ajoutez lead_angle scheduling et calibration (essais).

Optionnel : injectez 3ᵉ harmonique petit à petit et mesurez réduction d’ondulation.

Tune current PI → tune speed PI → réévaluer.

Si vous voulez, je peux :

vous donner valeurs de départ de gains plus concrètes si vous me donnez l’inductance approximative, la résistance et la Vbus / Imax du moteur ;

générer un diagramme SVG ou un PDF du schéma (visuel) prêt à l’emploi ;

ou écrire le module C (ISR + PWM) minimal pour STM32 (HAL ou register-level) avec ces optimisations.
*/
/* bldc_trap_opt.c
 *
 * Pilotage BLDC 6-pas optimisé (courant régulé, PWM synchrone, deadtime comp,
 * shaping, 3rd-harm injection, lead angle).
 *
 * HAL-based code (STM32). Assumptions:
 *  - TIM_PWM (e.g. TIM1) generates center-aligned PWM and triggers an interrupt
 *    at the center point (CCx or update event). Configure ADC to sample
 *    currents synchronized at same instant or read shunt sensors in ISR.
 *  - Hall sensors provide one of 6 sectors; we derive electrical angle index.
 *
 * Hardware-specific: adapt TIM/ADC/Hall GPIO/ADC channel names.
 */

 #include "stm32f4xx_hal.h"
 #include <math.h>
 #include <stdint.h>
 #include <stdbool.h>
 
 /* ======== Hardware hooks (implement/rename per your board) ======== */
 extern TIM_HandleTypeDef htim1;      // PWM timer, center aligned
 extern ADC_HandleTypeDef hadc1;      // ADC for currents (or use DMA)
 extern volatile uint8_t hall_state;  // updated from EXTI ISR (1..6)
 uint32_t SystemCoreClock;            // provided by HAL
 
 // Implement these to read currents (phase A/B). If you have only one shunt,
 // reconstruct via Ia + Ib + Ic = 0 or sample phase shunts with timing.
 static inline float hw_read_current_A(void) { /* TODO: read ADC and convert */ return 0.0f; }
 static inline float hw_read_current_B(void) { /* TODO: read ADC and convert */ return 0.0f; }
 static inline float hw_read_current_C(void) { /* optional */ return -(hw_read_current_A()+hw_read_current_B()); }
 
 // Set PWM duties (0..1.0 floating). The implementation must apply deadtime and update CCR regs.
 static inline void hw_set_pwm_duties(float duty_a, float duty_b, float duty_c) {
     // TODO: convert to TIM CCRx registers. clamp 0..1
     if (duty_a < 0) duty_a = 0; if (duty_a > 1) duty_a = 1;
     if (duty_b < 0) duty_b = 0; if (duty_b > 1) duty_b = 1;
     if (duty_c < 0) duty_c = 0; if (duty_c > 1) duty_c = 1;
     // Example: __HAL_TIM_SET_COMPARE(&htim1, TIM_CHANNEL_1, (uint32_t)(duty_a * TIM1_PERIOD));
 }
 
 /* ======== Configurable parameters ======== */
 #define PWM_FREQ_HZ         20000.0f    // PWM carrier (16-32 kHz recommended). adjust to your HW
 #define CURRENT_LOOP_FREQ   4000.0f     // ISR rate (run current loop at this rate) - typically == PWM center ISR
 #define SPEED_LOOP_HZ       200.0f      // slower speed loop
 #define I_MAX               10.0f       // maximum phase current [A]
 #define VBUS                48.0f       // bus voltage [V] used for deadtime heuristics etc.
 
 /* PI controller params (tune for your motor) */
 typedef struct {
     float kp, ki;
     float integrator;
     float out_min, out_max;
 } PI_t;
 
 static PI_t pi_current = { .kp = 0.08f, .ki = 100.0f, .integrator = 0.0f, .out_min = -1.0f, .out_max = 1.0f };
 static PI_t pi_speed   = { .kp = 0.05f, .ki = 1.0f, .integrator = 0.0f, .out_min = -I_MAX, .out_max = I_MAX };
 
 /* Shaping / tapering */
 #define TAPER_ENABLED       1
 #define TAPER_TAU_US        80.0f       // time constant for short ramp in microseconds (adjust to inductance)
 
 /* 3rd harmonic injection */
 #define THIRD_HARM_ENABLED  1
 #define THIRD_HARM_AMPL     0.05f       // 3-10% of base current
 
 /* Deadtime compensation */
 #define DEADTIME_COMP_ENABLED 1
 #define DEADTIME_US         1.0f        // measured deadtime in microseconds (set from timer config)
 
 /* Lead angle scheduling (degrees) */
 #define LEAD_MIN_DEG        0.0f
 #define LEAD_MAX_DEG        20.0f       // up to ~10-30 deg depending on inductance/speed
 #define LEAD_OMEGA_START    100.0f      // rad/s at which lead starts increasing
 #define LEAD_OMEGA_END      1000.0f     // rad/s at which lead reaches max
 
 /* Safety */
 #define I_OVERCURRENT       (I_MAX * 1.2f)
 
 /* Internal state */
 volatile float speed_ref = 0.0f; // rad/s (set by user)
 static float speed_est = 0.0f;
 static uint32_t current_loop_counter = 0;
 static uint32_t speed_loop_counter = 0;
 static float iq_ref = 0.0f;
 
 /* Commutation table for 6 steps (High, Mid, Low). We'll map sectors 1..6 */
 typedef struct { int8_t high; int8_t mid; int8_t low; } comm_t;
 static const comm_t comm_table[6] = {
     /* sector: high, mid, low (phase indices A=0,B=1,C=2) */
     { 0, 1, 2 }, // Step 1: A+, B-, C float
     { 0, 2, 1 }, // Step 2: A+, C-, B float
     { 1, 2, 0 }, // Step 3: B+, C-, A float
     { 1, 0, 2 }, // Step 4: B+, A-, C float
     { 2, 0, 1 }, // Step 5: C+, A-, B float
     { 2, 1, 0 }  // Step 6: C+, B-, A float
 };
 
 /* Utility: clamp */
 static inline float clampf(float v, float lo, float hi) {
     if (v < lo) return lo;
     if (v > hi) return hi;
     return v;
 }
 
 /* PI update (delta-time provided) */
 static float pi_update(PI_t *pi, float err, float dt) {
     // Integrator with anti-windup (clamp)
     pi->integrator += err * pi->ki * dt;
     if (pi->integrator > pi->out_max) pi->integrator = pi->out_max;
     if (pi->integrator < pi->out_min) pi->integrator = pi->out_min;
     float out = pi->kp * err + pi->integrator;
     return clampf(out, pi->out_min, pi->out_max);
 }
 
 /* Deadtime compensation: simple model adding small offset depending on sign */
 static float deadtime_compensate(float duty, float dt_seconds) {
 #if DEADTIME_COMP_ENABLED
     // compute the effect of deadtime relative to PWM period
     float pwm_period = 1.0f / PWM_FREQ_HZ;
     float dead_fraction = DEADTIME_US * 1e-6f / pwm_period;
     // compensation proportional to distance from 0.5
     float k = dead_fraction * 0.5f; // tuning scalar
     if (duty > 0.5f) duty += k;
     else duty -= k;
 #endif
     return clampf(duty, 0.0f, 1.0f);
 }
 
 /* Tapering (shaping) helper.
    We implement a short first-order approach using a timestamp microseconds resolution.
    For simplicity we use a per-phase previous I_ref and a pseudo-timer heuristic. */
 static float tapered_ref_update(float prev_ref, float target_ref, float dt_us) {
 #if TAPER_ENABLED
     float tau = TAPER_TAU_US; // microseconds
     if (tau <= 0.0f) return target_ref;
     float alpha = 1.0f - expf(-dt_us / tau);
     return prev_ref + (target_ref - prev_ref) * alpha;
 #else
     (void)prev_ref; (void)target_ref; (void)dt_us;
     return target_ref;
 #endif
 }
 
 /* Third harmonic injection (small amplitude) */
 static float third_harm_component(float elec_angle_rad) {
 #if THIRD_HARM_ENABLED
     return THIRD_HARM_AMPL * sinf(3.0f * elec_angle_rad);
 #else
     (void)elec_angle_rad;
     return 0.0f;
 #endif
 }
 
 /* Map torque (Iq_ref) to per-phase currents for active phases.
    For trapezoidal BLDC, per-phase target currents are typically +/- Iq_ref on
    the two active phases (one positive, one negative). */
 static void map_torque_to_phase_currents(float iq, uint8_t sector /*1..6*/,
                                          float *iA_ref, float *iB_ref, float *iC_ref) {
     // default zeros
     *iA_ref = *iB_ref = *iC_ref = 0.0f;
     // sector index 1..6 -> comm_table index 0..5
     uint8_t idx = (sector - 1) & 0x07;
     comm_t c = comm_table[idx];
     // high phase -> positive, mid phase -> negative
     if (c.high == 0) *iA_ref = +iq;
     if (c.high == 1) *iB_ref = +iq;
     if (c.high == 2) *iC_ref = +iq;
     if (c.mid  == 0) *iA_ref = -iq;
     if (c.mid  == 1) *iB_ref = -iq;
     if (c.mid  == 2) *iC_ref = -iq;
 }
 
 /* Compute lead angle (deg) from estimated speed (rad/s) */
 static float compute_lead_deg(float omega_rad_s) {
     if (omega_rad_s <= LEAD_OMEGA_START) return LEAD_MIN_DEG;
     if (omega_rad_s >= LEAD_OMEGA_END) return LEAD_MAX_DEG;
     float t = (omega_rad_s - LEAD_OMEGA_START) / (LEAD_OMEGA_END - LEAD_OMEGA_START);
     return LEAD_MIN_DEG + t * (LEAD_MAX_DEG - LEAD_MIN_DEG);
 }
 
 /* Convert sector + lead_deg to an effective electrical angle (rad) for injection
    and for scheduling commutation. We'll approximate sector center angles:
    sector 1 -> 0..60deg, we take central angle 30deg + (sector-1)*60deg */
 static float sector_center_angle_rad(uint8_t sector) {
     float deg = 30.0f + (sector - 1) * 60.0f;
     return deg * (M_PI / 180.0f);
 }
 
 /* ======== Speed estimator (simple from Hall transitions) ========
    For robustness we assume hall_state updated elsewhere (EXTI on halls).
    Here we keep a simple moving average of delta times between transitions.
 */
 static volatile uint32_t hall_timestamp_ticks[6];
 static volatile uint8_t last_hall = 1;
 static uint32_t ticks_to_us(uint32_t ticks) {
     // use SysTick or timer ticks conversion; approximate with SystemCoreClock
     // TODO: replace with accurate timer tick -> microsecond mapping
     return (uint32_t)((ticks * 1e6f) / SystemCoreClock);
 }
 
 /* Call this from Hall EXTI ISR with current tick (e.g. TIM counter) */
 void hall_transition_callback(uint8_t new_state, uint32_t tick_now) {
     // sectors 1..6
     if (new_state < 1 || new_state > 6) return;
     last_hall = new_state;
     // store timestamp for this sector
     hall_timestamp_ticks[new_state - 1] = tick_now;
     // optional: compute delta with previous same sector or neighboring
 }
 
 /* ======== PWM center ISR: main current-loop executes here ========
  * This should be triggered at the center of PWM (synchronized), so ADC sampling
  * can also occur at same instant for accurate current measurement.
  */
 void TIM1_CC_IRQHandler(void) {
     // Clear IRQ flag depending on HAL config
     HAL_TIM_IRQHandler(&htim1); // keep HAL prologue if used
 
     // IN PRACTICE: ensure interrupts shortest possible: read ADC results (already DMA-ed or sampled)
     // Read phase currents
     float Ia = hw_read_current_A();
     float Ib = hw_read_current_B();
     float Ic = hw_read_current_C(); // optional
 
     // Basic speed estimation (placeholder): user will replace with better estimator
     // Here we only read hall_state (1..6) and optionally compute speed externally
     uint8_t sector = hall_state;
     if (sector < 1) sector = 1;
 
     // Speed loop (run every N current loops)
     current_loop_counter++;
     // compute dt for PI integrators
     float dt = 1.0f / CURRENT_LOOP_FREQ; // seconds
     if (current_loop_counter >= (uint32_t)(CURRENT_LOOP_FREQ / SPEED_LOOP_HZ)) {
         current_loop_counter = 0;
         // simple speed PI: estimate speed_est elsewhere; here we keep last value
         float speed_err = speed_ref - speed_est;
         iq_ref = pi_update(&pi_speed, speed_err, 1.0f / SPEED_LOOP_HZ); // faster update ok
         iq_ref = clampf(iq_ref, -I_MAX, I_MAX);
     }
 
     // Map torque to phase currents for active sector
     float iA_ref, iB_ref, iC_ref;
     map_torque_to_phase_currents(iq_ref, sector, &iA_ref, &iB_ref, &iC_ref);
 
     // Tapering: need dt_us since last commutation (we approximate dt as 1/current_loop_freq in seconds -> us)
     float dt_us = dt * 1e6f;
     static float prev_iA_ref = 0.0f, prev_iB_ref = 0.0f, prev_iC_ref = 0.0f;
     iA_ref = tapered_ref_update(prev_iA_ref, iA_ref, dt_us);
     iB_ref = tapered_ref_update(prev_iB_ref, iB_ref, dt_us);
     iC_ref = tapered_ref_update(prev_iC_ref, iC_ref, dt_us);
     prev_iA_ref = iA_ref; prev_iB_ref = iB_ref; prev_iC_ref = iC_ref;
 
     // CURRENT PI per-phase
     // For phases that should be floating (zero reference) the PI should be disabled or clamped to zero.
     float dutyA = 0.5f, dutyB = 0.5f, dutyC = 0.5f; // 0.5 = neutral in center-aligned PWM mapping; we'll map to 0..1
     // Convert current PI output to duty in 0..1 domain. We use simple proportional mapping:
     // duty = 0.5 + (Vphase/Vbus) but since we control current with voltage, use PI returns -1..1 scaled -> duty
     // Here we use pi_current per phase: reset integrators if reference is zero to avoid windup
     if (fabsf(iA_ref) > 1e-6f) {
         float errA = iA_ref - Ia;
         float outA = pi_update(&pi_current, errA, dt);
         dutyA = 0.5f + outA * 0.5f; // outA [-1,1] -> duty [0,1] (tuning may require scaling)
     } else {
         // optionally decay integrator
     }
     if (fabsf(iB_ref) > 1e-6f) {
         float errB = iB_ref - Ib;
         float outB = pi_update(&pi_current, errB, dt);
         dutyB = 0.5f + outB * 0.5f;
     }
     if (fabsf(iC_ref) > 1e-6f) {
         float errC = iC_ref - Ic;
         float outC = pi_update(&pi_current, errC, dt);
         dutyC = 0.5f + outC * 0.5f;
     }
 
     // Third harmonic injection: compute electrical angle for injection
     float elec_ang = sector_center_angle_rad(sector);
     // add lead angle (deg -> rad)
     float lead_deg = compute_lead_deg(speed_est);
     float lead_rad = lead_deg * (M_PI / 180.0f);
     elec_ang += lead_rad;
     // Add small 3rd harmonic into duties (relative)
     float thr = third_harm_component(elec_ang);
     dutyA += thr;
     dutyB += thr;
     dutyC += thr;
 
     // Deadtime compensation
     dutyA = deadtime_compensate(dutyA, dt);
     dutyB = deadtime_compensate(dutyB, dt);
     dutyC = deadtime_compensate(dutyC, dt);
 
     // Clamp final duties 0..1
     dutyA = clampf(dutyA, 0.0f, 1.0f);
     dutyB = clampf(dutyB, 0.0f, 1.0f);
     dutyC = clampf(dutyC, 0.0f, 1.0f);
 
     // Safety: overcurrent
     if (fabsf(Ia) > I_OVERCURRENT || fabsf(Ib) > I_OVERCURRENT || fabsf(Ic) > I_OVERCURRENT) {
         // Disable PWM / shutdown
         // TODO: implement safe shutdown
         hw_set_pwm_duties(0.0f, 0.0f, 0.0f);
         return;
     }
 
     // Apply PWM duties (synchronous freewheeling is controlled in timer complementary outputs config)
     hw_set_pwm_duties(dutyA, dutyB, dutyC);
 
     // Update any diagnostic/state
     // speed_est update could be done here from hall transitions (not implemented)
 }
 
 /* ======== Hall EXTI Handler (example) ========
    Call hall_transition_callback(new_state, tick_now) from your external interrupt handler.
 */
 
 /* ======== Public API ======== */
 void bldc_init(void) {
     // Initialize timers, ADC, NVIC for TIM1 CC interrupt, hall EXTI, start PWM outputs etc.
     // TODO: configure TIM1 for center-aligned PWM, complementary outputs, deadtime (DT).
 }
 
 void bldc_set_speed_ref(float omega_rad_s) {
     speed_ref = omega_rad_s;
 }
 
 float bldc_get_speed_est(void) {
     return speed_est;
 }
 
 void bldc_stop(void) {
     // ramp down, disable PWM etc.
     hw_set_pwm_duties(0,0,0);
 }
 
 /* ======== Additional notes to integrate ========
  * - Configure TIM1 in center-aligned mode, with capture/compare interrupt at center point (use TIMx_CC or update).
  * - Configure ADC sampling to occur at center of PWM and either DMA into buffer or read in ISR quickly.
  * - Hall sensors: implement EXTI interrupts on hall GPIOs; decode 3-bit hall_state into sector 1..6.
  * - Tune PI gains carefully: start with low Kp, increase Ki slowly. Use scope/logging to inspect currents and duties.
  * - For single-shunt measurement, you'll need a different reconstruction algorithm in hw_read_current_*.
  * - For sensorless (ZC) replace hall_state logic with zero-cross detection & rotor angle estimator; preserve current-loop approach.
  *
  * This module is intentionally generic. Replace hardware helper functions (hw_*) with your board-specific code.
  */
 

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  // autre exemple de chat gpt
  // -----------------------------------------------------------------------------
// bldc_hall_trapezoidal_full.c
// BLDC trapezoidal (six-step) with Hall sensors
// Features:
//  - Peak (crête) current regulation (fast hardware/shunt reading hook)
//  - Synchronous PWM (center-aligned assumed in BSP)
//  - PWM shaping (pseudo-sinus / LUT per 60° sector)
//  - Optional 3rd-harmonic injection to boost fundamental without overmodulation
//  - Lead-angle (advance) adaptive with speed
//  - Safe, portable hardware abstraction layer (callbacks)
//  - Designed as a single-file module to be adapted to any MCU (STM32 example glue notes at bottom)
// -----------------------------------------------------------------------------

#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <math.h>

// --------------------------- CONFIG (tweak for your motor) -------------------
#ifndef PWM_TOP
#define PWM_TOP             1200u   // timer PWM period (center-aligned assumed)
#endif
#ifndef PWM_MIN_START
#define PWM_MIN_START       60u     // minimal duty to start
#endif
#ifndef SHAPING_STEPS
#define SHAPING_STEPS       32      // resolution per 60° sector
#endif
#ifndef POLE_PAIRS
#define POLE_PAIRS          7       // default pole pairs - set for your motor
#endif
#ifndef LEAD_MIN_DEG
#define LEAD_MIN_DEG        2
#endif
#ifndef LEAD_MAX_DEG
#define LEAD_MAX_DEG        30
#endif
#ifndef LEAD_RPM_LOW
#define LEAD_RPM_LOW        200
#endif
#ifndef LEAD_RPM_HIGH
#define LEAD_RPM_HIGH       4000
#endif
#ifndef CURR_LOOP_HZ
#define CURR_LOOP_HZ        5000    // inner current loop freq (if used)
#endif

// --------------------------- HARDWARE ABSTRACTION -----------------------------
// Fill these callbacks with your board-specific implementations.

typedef struct {
    // Set per-phase PWM duty (0..PWM_TOP). Implementation should implement
    // complementary outputs and deadtime; this API is the high-level duty.
    void (*pwm_set_u)(uint16_t duty);
    void (*pwm_set_v)(uint16_t duty);
    void (*pwm_set_w)(uint16_t duty);

    // Enable/disable gate driver power
    void (*power_enable)(bool en);

    // Read Hall sensors (bits H3..H1 -> bits 2..0)
    uint8_t (*hall_read)(void);

    // High-resolution time in microseconds
    uint32_t (*time_us)(void);

    // Schedule a one-shot callback in microseconds (must be non-blocking)
    // The provided callback will be called in interrupt context.
    void (*schedule_oneshot_us)(uint32_t us, void (*cb)(void));

    // Instantaneous peak current check (returns true if current >= limit)
    bool (*is_overcurrent)(void);

    // Read calibrated shunt ADC in mA (signed). Optional; if NULL, overcurrent used only.
    int32_t (*read_shunt_ma)(void);

    // Optional fault indicator
    void (*fault)(bool on);

    // Tick frequency (for time_us conversion if needed) - not mandatory if time_us returns us
    uint32_t reserved;
} bldc_hw_t;

// ------------------------------- INTERNAL DATA --------------------------------
typedef enum { ST_STOP=0, ST_RUN } bldc_state_t;

typedef struct {
    bldc_hw_t hw;
    volatile bldc_state_t state;

    // Control
    volatile int16_t speed_ref_rpm;
    volatile uint16_t torque_ref_duty; // open-loop torque control (0..PWM_TOP)

    // Runtime
    volatile uint16_t duty_now; // current commanded duty (0..PWM_TOP)
    volatile uint8_t last_hall;
    volatile uint32_t last_hall_us;
    volatile uint32_t last_period_us; // 60° elec
    volatile int16_t speed_rpm; // filtered

    // Lead angle
    uint8_t lead_deg;

    // Shaping LUT (0..PWM_TOP) of size SHAPING_STEPS+1 (per 60°)
    uint16_t shaping_lut[SHAPING_STEPS+1];
    bool shaping_enable;

    // 3rd harmonic injection amplitude (0..1.0)
    float third_harmonic_amp;

    // Peak-current (crête) target in mA (optional if read_shunt_ma available)
    int32_t peak_current_ma;

    // simple PI for torque control (could be current-loop in closed-loop system)
    int32_t pi_kp_q15;
    int32_t pi_ki_q15;
    int32_t pi_acc; // integrator accumulator

    // motor geometry
    uint16_t pole_pairs;
} bldc_t;

static bldc_t g;

// ------------------------------- HELPERS -------------------------------------
static inline uint8_t hall_valid(uint8_t h){ return (h==1||h==3||h==2||h==6||h==4||h==5); }

// map hall code to sector index (0..5) consistent with typical BLDC sequence
// input h = bits H3 H2 H1 (2..0)
static inline int hall_to_sector(uint8_t h){
    // sequence: 001(1),101(5),100(4),110(6),010(2),011(3)
    switch(h&7){
        case 1: return 0;
        case 5: return 1;
        case 4: return 2;
        case 6: return 3;
        case 2: return 4;
        case 3: return 5;
        default: return -1;
    }
}

// compute lead deg mapping from RPM
static uint8_t compute_lead_deg(int16_t rpm){
    if(rpm <= LEAD_RPM_LOW) return LEAD_MIN_DEG;
    if(rpm >= LEAD_RPM_HIGH) return LEAD_MAX_DEG;
    int num = (rpm - LEAD_RPM_LOW) * (LEAD_MAX_DEG - LEAD_MIN_DEG);
    int den = (LEAD_RPM_HIGH - LEAD_RPM_LOW);
    return (uint8_t)(LEAD_MIN_DEG + num/den);
}

// simple filtered RPM update (IIR)
static void update_speed_from_period(uint32_t per_us){
    if(per_us==0) return;
    // rpm = 10e6 / (per_us * pole_pairs)
    uint32_t tmp = 10000000u / (per_us * (uint32_t)g.pole_pairs);
    if(tmp>32767u) tmp = 32767u;
    int16_t rpm_meas = (int16_t)tmp;
    // IIR: new = a*old + (1-a)*meas ; choose a=0.8
    g.speed_rpm = (int16_t)((g.speed_rpm*8 + rpm_meas*2)/10);
}

// build shaping LUT per sector (0..1 scaled to PWM_TOP)
static void build_shaping(void){
    for(int i=0;i<=SHAPING_STEPS;i++){
        float x = (float)i / (float)SHAPING_STEPS; // 0..1 across 60°
        // baseline trapezoidal target (0..1) approximated with smoothed corners
        // use cos transition for smoothing: s=0.5*(1-cos(pi*x)) trimmed to trapezoid
        float s = 0.5f*(1.0f - cosf(M_PI * x));
        // clamp near ends to mimic trapezoid plateau
        if(x<0.15f) s *= (x/0.15f);
        if(x>0.85f) s *= ((1.0f - x)/0.15f);
        if(s<0.0f) s=0.0f; if(s>1.0f) s=1.0f;
        g.shaping_lut[i] = (uint16_t)(s * (float)PWM_TOP + 0.5f);
    }
}

// add 3rd harmonic injection to a phase magnitude (per electrical angle 0..2pi)
static float third_harmonic_inject(float fundamental, float elec_angle){
    if(g.third_harmonic_amp<=0.0f) return fundamental;
    // third harmonic: sin(3*theta) scaled so peak-to-peak doesn't exceed limits
    float inj = sinf(3.0f * elec_angle) * g.third_harmonic_amp;
    return fundamental + inj;
}

// ------------------------------- CORE: SECTOR APPLY --------------------------
// Apply duty to the two active phases for a given sector index (0..5)
// We use pwm_set_X(duty) where duty is 0..PWM_TOP. The BSP must implement
// complementary outputs, deadtime, and center-aligned timing.
static void sector_apply(int sector, uint16_t duty_u, uint16_t duty_v, uint16_t duty_w){
    // For safety clamp
    if(duty_u > PWM_TOP) duty_u = PWM_TOP;
    if(duty_v > PWM_TOP) duty_v = PWM_TOP;
    if(duty_w > PWM_TOP) duty_w = PWM_TOP;
    g.hw.pwm_set_u(duty_u);
    g.hw.pwm_set_v(duty_v);
    g.hw.pwm_set_w(duty_w);
}

// compute per-phase duties for given sector and normalized magnitude m(0..1)
// includes shaping and optional 3rd harmonic. The 'sector_pos' is position inside
// the 60° sector, as index 0..SHAPING_STEPS.
static void compute_and_set_pwm_for_sector(int sector, int sector_pos, uint16_t magnitude)
{
    // base shaped magnitude from LUT
    if(sector_pos < 0) sector_pos = 0; if(sector_pos > SHAPING_STEPS) sector_pos = SHAPING_STEPS;
    uint16_t base = g.shaping_lut[sector_pos]; // 0..PWM_TOP
    // scale base by requested magnitude (0..PWM_TOP)
    float scale = (float)magnitude / (float)PWM_TOP;
    float m = (float)base * scale / (float)PWM_TOP; // 0..1 factor on PWM_TOP

    // compute electrical angle for sector and pos
    // sector 0..5 maps to elec angle range [sector*60°, (sector+1)*60°)
    float sector_angle = (float)sector * (M_PI/3.0f);
    float pos_frac = (float)sector_pos / (float)SHAPING_STEPS;
    float elec = sector_angle + pos_frac * (M_PI/3.0f); // radians

    // apply third harmonic injection on the three phase magnitudes
    float mu = third_harmonic_inject(m, elec);
    float mv = third_harmonic_inject(m, elec - 2.0f*M_PI/3.0f);
    float mw = third_harmonic_inject(m, elec + 2.0f*M_PI/3.0f);

    // normalize to prevent clipping: find max and scale down if >1
    float maxv = mu; if(mv>maxv) maxv=mv; if(mw>maxv) maxv=mw;
    float clip = 1.0f; if(maxv>clip){ mu/=maxv; mv/=maxv; mw/=maxv; }

    uint16_t du = (uint16_t)(mu * (float)PWM_TOP + 0.5f);
    uint16_t dv = (uint16_t)(mv * (float)PWM_TOP + 0.5f);
    uint16_t dw = (uint16_t)(mw * (float)PWM_TOP + 0.5f);

    // apply to HW
    sector_apply(sector, du, dv, dw);
}

// ------------------------------- COMMUTATION & LEAD -------------------------
// Called when it's time to commutate (either immediate on Hall edge or scheduled)
void bldc_commutate_now(void)
{
    if(g.state != ST_RUN) return;
    uint8_t h = g.hw.hall_read() & 7;
    if(!hall_valid(h)){
        // invalid hall; fault
        if(g.hw.fault) g.hw.fault(true);
        g.state = ST_STOP; return;
    }
    uint32_t now = g.hw.time_us();
    uint32_t dt = 0;
    if(g.last_hall_us!=0) dt = now - g.last_hall_us;
    g.last_hall_us = now;
    if(dt>0 && dt<1000000u){
        g.last_period_us = dt;
        update_speed_from_period(dt);
    }
    g.last_hall = h;

    // compute lead angle and convert to time advance
    g.lead_deg = compute_lead_deg(g.speed_rpm);
    // advance = lead_deg/60 * period_us
    uint32_t advance_us = 0;
    if(g.last_period_us>0) advance_us = ((uint32_t)g.lead_deg * g.last_period_us) / 60u;
    // compute sector and sector_pos. We want to schedule next commutation earlier
    // so we set a oneshot to fire at (period_us - advance_us)
    uint32_t schedule_delay = (g.last_period_us>advance_us) ? (g.last_period_us - advance_us) : (g.last_period_us/2);

    // compute target magnitude from PI or open-loop torque_ref
    uint16_t mag = g.torque_ref_duty;
    if(g.speed_ref_rpm!=0){
        // PI controller (Q15 style)
        int32_t err = (int32_t)g.speed_ref_rpm - (int32_t)g.speed_rpm;
        g.pi_acc += (g.pi_ki_q15 * err) >> 15;
        // clamp integrator
        if(g.pi_acc > ((int32_t)PWM_TOP<<12)) g.pi_acc = ((int32_t)PWM_TOP<<12);
        if(g.pi_acc < 0) g.pi_acc = 0;
        int32_t out = ((g.pi_kp_q15 * err) >> 15) + (g.pi_acc >> 12);
        if(out<0) out = 0; if(out> (int32_t)PWM_TOP) out = PWM_TOP;
        mag = (uint16_t)out;
    }

    // Peak current protection (fast): if overcurrent then reduce mag
    if(g.hw.is_overcurrent && g.hw.is_overcurrent()){
        // quick clamp: reduce duty by 20% or to zero if persistent
        mag = (mag * 80) / 100;
    }

    // Determine sector and advance scheduling
    int sector = hall_to_sector(h);
    if(sector<0){ if(g.hw.fault) g.hw.fault(true); g.state=ST_STOP; return; }

    // Immediately set PWM for the current sector (simple approach):
    // compute sector_pos ~ midpoint of sector (may be refined). For simplicity
    // we take sector_pos = SHAPING_STEPS/2 to represent average within sector.
    int sector_pos = SHAPING_STEPS/2;

    if(g.shaping_enable) {
        compute_and_set_pwm_for_sector(sector, sector_pos, mag);
    } else {
        // fallback: simple two-phase PWM at 'mag' on active phases
        switch(h){
            case 1: g.hw.pwm_set_u(mag); g.hw.pwm_set_v(mag); g.hw.pwm_set_w(0); break;
            case 5: g.hw.pwm_set_u(mag); g.hw.pwm_set_v(0); g.hw.pwm_set_w(mag); break;
            case 4: g.hw.pwm_set_u(0); g.hw.pwm_set_v(mag); g.hw.pwm_set_w(mag); break;
            case 6: g.hw.pwm_set_u(mag); g.hw.pwm_set_v(mag); g.hw.pwm_set_w(0); break;
            case 2: g.hw.pwm_set_u(mag); g.hw.pwm_set_v(0); g.hw.pwm_set_w(mag); break;
            case 3: g.hw.pwm_set_u(0); g.hw.pwm_set_v(mag); g.hw.pwm_set_w(mag); break;
        }
    }

    // schedule next commutation (one-shot) to anticipate lead
    if(g.hw.schedule_oneshot_us && g.last_period_us>0){
        g.hw.schedule_oneshot_us(schedule_delay, bldc_commutate_now);
    }
}

// Hall IRQ handler (to be called in EXTI ISR) - minimal, defers to commutate
void bldc_hall_irq_handler(void)
{
    // immediate processing is acceptable: call commutate now
    bldc_commutate_now();
}

// ------------------------------- PUBLIC API ----------------------------------
void bldc_init(const bldc_hw_t *hw)
{
    memset(&g,0,sizeof(g));
    g.hw = *hw;
    g.state = ST_STOP;
    g.torque_ref_duty = PWM_MIN_START;
    g.duty_now = 0;
    g.shaping_enable = true;
    g.third_harmonic_amp = 0.08f; // small amplitude by default
    g.peak_current_ma = 0; // disabled
    g.pi_kp_q15 = (int32_t)(0.04f * 32768.0f); // tune
    g.pi_ki_q15 = (int32_t)(0.005f * 32768.0f);
    g.pole_pairs = POLE_PAIRS;
    build_shaping();
}

void bldc_start(void)
{
    if(g.state==ST_RUN) return;
    if(g.hw.power_enable) g.hw.power_enable(true);
    g.state = ST_RUN;
    // initial commutation to align outputs to Hall
    bldc_commutate_now();
}

void bldc_stop(void)
{
    g.state = ST_STOP;
    // zero PWM
    g.hw.pwm_set_u(0); g.hw.pwm_set_v(0); g.hw.pwm_set_w(0);
    if(g.hw.power_enable) g.hw.power_enable(false);
}

void bldc_set_speed_ref(int16_t rpm){ g.speed_ref_rpm = rpm; }
void bldc_set_torque_ref(uint16_t duty){ g.torque_ref_duty = clamp_u16(duty, 0, PWM_TOP); }

void bldc_enable_shaping(bool en){ g.shaping_enable = en; }
void bldc_set_third_harmonic(float amp){ g.third_harmonic_amp = amp; }
void bldc_set_peak_current_ma(int32_t ma){ g.peak_current_ma = ma; }

// ------------------------------- CLAMP HELPERS -------------------------------
static inline uint16_t clamp_u16(int v, int lo, int hi){ if(v<lo) return (uint16_t)lo; if(v>hi) return (uint16_t)hi; return (uint16_t)v; }

// ------------------------------- EXAMPLE GLUE NOTES --------------------------
/*
STM32 minimal integration notes (not compiled here):
- Configure TIM1/8 for center-aligned PWM, three channels with complementary outputs.
- Implement pwm_set_u/v/w to write CCR registers (0..PWM_TOP).
- Use ADC or comparator + DMA to sample current shunt. Provide read_shunt_ma() and is_overcurrent().
- Configure EXTI for Hall inputs (or use TIM Hall interface), call bldc_hall_irq_handler() on change.
- Implement schedule_oneshot_us using a general-purpose timer in one-shot mode; its callback must call bldc_commutate_now().
- Ensure interrupt priorities: Hall IRQ and one-shot should be highest to keep commutation tight.

Example stub functions:

uint8_t hw_hall_read(void){ return (H3_read()<<2)|(H2_read()<<1)|H1_read(); }
void hw_pwm_set_u(uint16_t d){ TIM1->CCR1 = d; }
... similar for V/W
uint32_t hw_time_us(void){ return DWT->CYCCNT / (SystemCoreClock/1000000); }
void hw_sched_us(uint32_t us, void(*cb)(void)){
   // configure TIMx one-shot with callback
}

In practice you may want to implement DMA-driven PWM shaping: precompute a waveform table per sector (SHAPING_STEPS) and feed CCR registers via DMA synchronized to PWM update event — this minimizes CPU load and produces very smooth currents.
*/

// -----------------------------------------------------------------------------
// End of file
// -----------------------------------------------------------------------------
